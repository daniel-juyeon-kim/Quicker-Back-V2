## 문제

이전 프로젝트에서 개발자가 직접 테스트를 하면서 기능을 개발했습니다. 하지만 리팩토링하면서 아래와 같은 문제를 겪었습니다.

- 리팩토링 전, 후 같은 동작을 하는지 의심됨, 처음부터 다시 테스트해야 함
- 개발자가 직접 하는 테스트는 일시적이고 시간이 오래 걸림
- 배포 후 놓친 엣지 케이스가 나옴

## 해결

테스트 코드를 이용해 해결해 보겠습니다. 이 글에서는 테스트 코드 중 작성이 어려운 부분을 어떻게 테스트했는지 설명하겠습니다.

### 레포지토리 계층 테스트

레포지토리 계층은 DB에 의존적인 계층으로 DB에 접근하여 데이터를 처리합니다.

보통 외부 환경에 의존적인 코드를 테스트할 때 의존성을 외부로 추출합니다. 하지만 레포지토리 계층에서는 사용할 수 없는 방법입니다. 레포지토리 계층을 테스트하려면 실제 DB를 사용해야하고 환경이 다르면 테스트 결과도 달라집니다. 그래서 인 메모리 DB나 도커 가상 DB를 사용해 테스트 환경을 고정하는 방법을 생각했습니다. 아래 장단점을 비교 후 인 메모리 DB를 사용했습니다.

#### 인 메모리 DB 장단점

장점

- 테스트 속도 빠름
- 설정이 많지 않음
- 배포될 DB에만 의존하는 코드를 피할 수 있음

단점

- 배포와 테스트 환경의 DB가 다름

#### 도커 가상 DB 장단점

장점

- 배포 환경과 동일한 DB를 사용

단점

- 인 메모리 DB보다 테스트 속도가 느림
- 도커 설정해아 함
  <!-- - 도커 설정 파일 작성이 귀찮음
  - CI에서 테스트 환경 설정에 시간이 걸림 -->

### 외부 API, 레포지토리에 의존하는 코드 테스트

외부 API, DB는 프로젝트에서 어댑터로 추상화합니다. 어뎁터와 관련된 코드를 어떻게 테스트 했는지 설명하겠습니다.

DB 어댑터인 레포지토리는 [레포지토리 계층 테스트](#레포지토리-계층-테스트)에서 설명한 방법으로 테스트할 수 있습니다. 그러나 외부 API 어댑터나 어댑터에 의존하는 코드는 사용 요금, 화이트리스트, API 서버 상태에 따라 테스트 결과가 달라집니다.

이럴때 모킹을 사용할 수 있습니다. 모킹은 테스트에 필요한 의존성을 가짜로 만들고 동작을 가정해 테스트합니다. 모킹은 가짜이기 때문에 외부 요인에 영향을 받지 않아 테스트 결과가 달라지지 않습니다. 모킹을 사용할 때는 실제 동작이 아니므로 주의해서 사용해야 합니다.

프로젝트에서 Slack, Naver SMS, Tmap 등의 외부 API를 감싼 어댑터를 모킹해서 테스트했습니다.

## 성과

프로젝트에 테스트 코드를 도입하면서 아래와 같은 이점이 있었습니다.

- 테스트 커버리지 95.52%
- 리팩토링 전/후 같은 동작을 보장(안정적인 리팩토링 가능)
- 지속적이고 빠른 테스트
- 엣지 케이스가 누락될 확률이 줄어듦
- 의도대로 동작하는 코드를 작성할 확률이 높음
